# 前端性能优化
前端性能优化可以分为三个level：静态资源优化、接口访问优化、页面渲染速度优化，在操控门槛上依次递增，优化效果上越发没有这么明显，所以很多小团队只会做到了第一个level
追求极致的前端性能体验，提升自己的level，come on ~
## 静态资源优化
这个level，主要是减少静态资源的加载时间，主要包括html、css、js和图片文件，静态资源的加载时间是前端性能最大的瓶颈（特别是图片），现如今优化的手段也很丰富，以下简要列举几种常用的方法

1. 合并css、js文件，制作雪碧图：减少http的请求次数，节省网络请求时间

2. 静态资源cdn分发：客户端可以通过最佳的网络链路加载静态资源

3. js、css文件压缩，图片压缩，gzip压缩：减少请求返回的数据量

4. 静态资源缓存机制

5. 权衡dns的查找

### CDN内容分发网络
CDN，Content Delivery Network：基于内容的分布式分发网络。 简单的说CDN就是让原本上海的浏览器要访问北京主站内容的请求转而由部署在上海或南京的缓存来受理，这样请求的数据只需经过一跳或有限的几跳就能到达请求端，有效利用带宽并且降低主站压力，对于电子商务网站和搜索引擎网站以及门户网站，CDN的合理应用显得尤为重要。

一般需要CDN服务的网站会选择以下的组织方案：

1. 通过租用的IDC提供额外的CDN服务；

2. 购买专业的CDN服务商的服务；

3. 自己组建CDN网络；

CDN设计目的是实现WEB内容的负载均衡，防止出现访问请求热点，延时响应等WEB请求通病。基于此，CDN的特点可以说有：

1. 分布式存储

2. 通过智能 DNS解析 或 http重定 向实现内容分发的负载均衡

3. 全局负载均衡管理与内容管理

**CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，访问使用CDN缓存后的网站的过程**:

1. 用户向浏览器提供要访问的域名。

2. 浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实 际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。

3. 此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器发出访问请求。

4. 缓存服务器根据浏览器提供的要访问的域名，通过Cache**内部专用DNS解析**得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求。

5. 缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程。
[引用](https://blog.csdn.net/Dustin_CDS/article/details/79548191)
### GZIP 压缩

为了减少传输的数据，压缩是一个不错的选择，而 HTTP 协议支持 GZIP 的压缩格式，服务器响应的报头包含 Content-Encoding: gzip，它告诉浏览器，这个响应的返回数据，已经压缩成 GZIP 格式，浏览器获得数据后要进行解压缩操作。这在一定程度可以减少服务器传输的数据，提高系统性能。

说它方便，是因为你不需要为它写任何额外的代码，只需要在http服务器上加上配置都行了，现在主流的http服务器都支持gzip，各种服务器的配置这里就不一一介绍(其实是我不知道怎么配)，

**比较适合启用gzip压缩的文件有如下这些**：

1. javascript

2. CSS

3. HTML，xml

4. plain text

hoho,1个gif图片经过gzip压缩后反而变大了???这是因为图片本来就是一种压缩格式，gzip不能再进行压缩，反而会添加1些额外的头部信息，所以图片会变大。

在测试过程中，发现jpg的图片经过gzip压缩后会变小,不知道为何，可能跟图片压缩方式有关。不过压缩比率也比较小，所以就算是jpg，建议也不要开启gzip压缩。

### 静态资源缓存机制

我们在写前端页面的时候，经常要引入多个css、js文件，这些文件中，有一些文件是不太需要改动的，但是这些不太需要改动的文件，如果每次用户访问页面都要重新加载就会很影响性能。合理的做法是对于更新频率不太高的文件，让用户能够利用本地缓存。

**浏览器缓存的分类**：

1）强制缓存：缓存资源未过有效期则不需要请求资源。HTTP首部字段利用catch-control,Expires设置缓存过期时间.

Expires：

Expires: Thu, 10 Nov 2017 08:45:11 GMT

这个字段表示的是缓存到期时间

绝对时间，即服务器时间。浏览器会检查当前时间，如果还没有到失效时间，则会直接使用缓存文件。但是因为这个字段中使用的是绝对时间，可能出现客户端与服务器时间不同的情况，而且客户端用户可以自己修改时间。

catch-control

Cache-Control: max-age=2592000

这个字段表示的也是过期时间，以上面为例就是2592000s后过期。但是它用的是相对时间，即使客户端时间改变，相对时间也不会随之改变，这确保服务器和客户端的时间一致性。

2）对比缓存：从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果已经更新，则返回新数据和新缓存，如果没有更新，则返回304状态码，通知客户端缓存未更新，可以使用缓存。通过HTTP的last-modified,Etag字段判断。对比缓存和强制缓存相比，更加适合于一些经常要更新的资源文件。

Last-Modified:

Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT

第一次请求资源时，服务器返回最后一次更新资源时间。浏览器下一次请求资源时，就会发送If-Modified-Since字段。

If-Modified-Since：再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，如果相等，则表示未修改，响应304，让浏览器利用缓存；反之，则表示修改了，缓存过期，响应200状态码，返回数据。

这个字段可以和Cache-Control配合使用。

但是他还是有一定缺陷的：

如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

## 接口访问优化

1. 静态资源加载完成了，页面依然还在转菊花，用户依然还在等待。现如今web应用已经走过完全由php和jsp等后端脚本语言渲染界面的时代，ajax异步加载数据的方式已经成为主流，各种前端的mvc框架层出不穷，先加载静态资源，在执行js中的ajax请求到后台请求数据，重新渲染界面已经是一种通行的方案，这样便出现了静态资源加载完成，页面可见，然而用户还需要等待请求数据的进度条的情况（特别是接口访问速度慢的时候）


2. 用户点击任意一个按钮，进度条加载了半天，也没有响应。很多复杂的功能需要并行或者串行的请求很多接口才能完成，前端的网络状况稍微差一点，给与用户的体验都极差。

以上两个问题在网络情况优异，接口请求速度快的情况下都不是问题，然而终端如果是一个手机，常常连wifi都不能保证，3g/4g的网络你能期待它有多快，所以优化的潜力是巨大的。

### 首屏直出、同构
对于上述的问题一，如果页面的初始化数据，在后端完成渲染，其它的用户交互使用ajax的方式完成，也就是传统意义上的首屏直出，就可以得到很好的解决。

这种介于完全后端渲染和完全ajax渲染的方式是一个不错的思路，但是在node出现之前，很多人宁愿容忍首屏加载的菊花，也不愿意使用，为什么？因为前端和后端要维护两套模板，令人抓狂。

node出来之后，前后端都都可以使用js语言，前后端同构（前端和后台公用模板代码）使得首屏直出重新拥有了生存的土壤，所以同构直出现在常常相提并论，形同一个成语。

### 接口合并
一个交互需要请求多个并行或串行接口实属正常，前端使用3g/4g等弱网络也着实是不可抗因素，所以最好的办法就是通过接口合并的方式来提高接口访问速度

后台提供的接口有其既有粒度，强行合并不合时宜，提供一个新的合并的接口也缺乏机动性（前端发现一个新的合并需求，就要求后端提供一个接口，后端有开发工作量不说，还得没完没了的发版）

如果把接口合并的主动权交给前端，那情况将会好很多，前端是最接近战火的地方，最知道应该如何组合接口。基于代理服务的接口合并方案应运而生（这是本人第一个值得骄傲的原创方案，这其中还包含了node实现，想想还有点小鸡动~）

## 页面渲染速度优化
在页面不复杂、dom层次不深的情况下，完成以上两个level，就已经足够了。然而在复杂的页面上，却还有很大的优化空间，页面渲染速度的优化很大的程度上依托于程序员的个人编程素质，下面简要列举几点：

1. css放在顶部：优先渲染

2. js放在底部：避免阻塞

3. 减少DOM元素数量：这个最能体现变成水平了

4. img标签要设置高宽：减少重绘重排

虚拟dom的渲染方案，也能极大的提升渲染速度，还没接触的同学还不赶紧尝尝鲜~~
[http优化](http://web.jobbole.com/90521/)
[rem](https://blog.csdn.net/YeShenLiaoSuiFeng/article/details/77282296)
[路由](https://segmentfault.com/a/1190000007238999)